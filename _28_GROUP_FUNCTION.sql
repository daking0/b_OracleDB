--1)주제 : 그룹 함수
--        검색된 여러 행을 이용하여 통계 검색하는 함수
--
--2) 그룹함수의 종류
--함수명       기능
------------------------------------------------------------
--MAX         값들 중에 최대값을 반환한다
--            MAX(컬럼)
------------------------------------------------------------
--MIN         값들 중에 최소값을 반환한다
--            MIN(컬럼)
------------------------------------------------------------
--AVG         평균 값을 계산한다
--            AVG(컬럼)
------------------------------------------------------------
--COUNT       반환 행의 수를 계산한다
--            COUNT(컬럼|*)
------------------------------------------------------------
--SUM         합계를 계산한다
--            SUM(컬럼)
------------------------------------------------------------
--STDDEV      표준편차를 계산한다
--            STDDEV(컬럼)
------------------------------------------------------------
--VARIANCE    분산을 계산한다
--            VARIANCE(컬럼)
------------------------------------------------------------
--a) null값을 무시한다
--b) 반드시 단 하나의 값만을 반환한다
--c) GROUP BY 설정 없이 일반 컬럼과 기술될 수 없다
------------------------------------------------------------
--사원의 평균 급여를 검색한다
--SELECT AVG(sal)평균급여, ROUND(AVG(sal)) 평균급여
--FROM EMP;
--
--사원들에게 지급된 보너스 총합과 보너스 평균을 검색하라
--SELECT SUM(comm) "보너스 총합", ROUND(AVG(comm)) 평균, COUNT(comm) 수령인원, ROUND(AVG(NVL(comm,0))) 환산평균,COUNT(*) 전체인원
--FROM emp;
--
--SELECT COUNT(*)
--FROM emp
--WHERE comm IS NOT NULL;
--
--1)주제 : 그룹 함수와 GROUP BY 절
--
--2)용법
--SELECT [DISTINCT/ALL] 컬럼 OR 그룹함수,...
--FROM 테이블
--WHERE 조건
--GROUP BY 그룹대상
--ORDER BY 정렬대상 [ASC/DESC]
--
--a) SELECT절에 그룹 함수와 컬럼명이 같이 기술된 경우
--   해당 컬럼은 반드시 GROUP BY 절에 그룹화 되어야 한다.
--b) SELECT절에 그룹 함수와 같이 쓰인 일반컬럼이
--   GROUP BY 절에 기술되지 않으면 카디널리티(cardinality)가 일치하지 않아 'ORA-00937: not a single-group group funcion'에러가 발생한다.
--c) 예전에는 오름차순 정렬이 기본으로 제공되었지만 현재는 상황에 따라 다르다.
--   ORDER BY 절을 이용 DESC로 변경 가능
--d) 결과 값이 정렬되기를 원한다면 반드시 ORDER BY 절을 추가한다
--e) GROUP BY 절은 반드시 그룹함수와 함께 쓰이며
--   그룹함수의 결과값은 GROUP BY절에 기술된 컬럼의 카디널리티에 의해 결정된다.
--
--업부별 평균 급여, 평균 연봉과 부서별 평균 연봉을 검색한다

SELECT job 업무 FROM emp;

SELECT AVG(sal) 평균급여, AVG(sal*12 + NVL(comm,0))평균급여
FROM emp;

--*SELECT절에 GROUP 함수와 같이 쓰인 모든 일반 컬럼은 반드시 GROUP BY 절에 기술되어야 한다

SELECT job 업무, ROUND(AVG(sal)) 평균급여, ROUND(AVG(sal*12 + NVL(comm,0)))평균연봉
FROM emp
GROUP BY job;

SELECT d.dno 부서번호, dname 부서명, ROUND(AVG(sal*12 + NVL(comm,0))) 연봉
FROM dept d, emp e
WHERE d.dno = e.dno
GROUP BY d.dno, dname;

SELECT dno 부서번호, dname 부서명, ROUND(AVG(sal*12 + NVL(comm,0))) 연봉
FROM dept
NATURAL JOIN emp
GROUP BY dno, dname;

--*카디널리티(cardinality)
--RDB에서 카디널리티란 검색되는 각 컬럼의 행의 수를 의미하거나 
--컬럼에 저장된 값의 종류를 의미하기도 한다
--예를 들면 학번이나 주민번호와 같이 중복이 없는 컬럼의 카디널리티는 매우 높고
--성별이나 학년 등은 중복 값이 많은 컬럼은 카디널리티가 낮다.
--그룹함수에서 이야기하는 카디널리티는 동시에 검색되는 각 컬럼과 항목들의행의 개수를 의미한다.
--그룹 함수를 사용하는 하나의 SELECT문자에서 각 검색항목들은 반드시 카디널리티가 일치해야 하며
--이를 위해서 GROUP BY 절이 이용된다.
--SELECT dno, AVG(sal) FROM emp;
--AVG(sal)에서 검색된 값은 당연히 1개이다(평균이니까)
--그러나 dno 컬럼의 값은 반드시 1개가 아닐 가능성이 매우 높다.
--PDMBS는 이렇게 검색되는 항목의 개수가 서로 다를 가능성이 있는 문장이 수행되면 
--'ORA-00937: 단일 그룹의 그룹함수가 아닙니다'에러를 발생시킨다.
--이때 일반 컬럼인 dno를 GROUPBY 절에 기술하면 dno값이 같은 행 기준으로 집합을 만들고
--여기에 대해서 AVG(sal)결과 값의 개수가 동일해진다.
--'그룹함수와 같이 검색되는 모든 컬럼은 반드시 GROUP BT절에 기술한다' 이것이 원칙이다

--이런 경우는 서브쿼리를 이용해야 한다.
--부서별로 급여 평균의 최대값과 최소값을 검색한다
SELECT dno, MAX(AVG(sal)), MIN(AVG(sal))
FROM emp
GROUP BY dno;
